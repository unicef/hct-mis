# Generated by Django 3.2.19 on 2023-07-05 13:35
from django.db import migrations, models

import abc
from typing import TYPE_CHECKING, Any, Optional

from django.core.paginator import Paginator
from django.db import transaction

if TYPE_CHECKING:
    from uuid import UUID

class GetProgramId(abc.ABC):
    obj: Any
    class_name: str
    nested_field: str

    def __init__(self, obj: Any) -> None:
        self.class_name: str = obj.__class__.__name__

        if self.class_name == "GrievanceTicket":
            # TODO: 'programme' removed in next migrations (m2m 'programs')
            self.obj = obj
            self.nested_field = "programme_id"

        elif self.class_name == "PaymentPlan":
            self.obj = obj.get_program
            self.nested_field = "pk"

        elif self.class_name == "CashPlan":
            self.obj = obj
            self.nested_field = "program_id"

        elif self.class_name == "PaymentVerificationPlan":
            self.obj = obj.get_program
            self.nested_field = "pk"

        elif self.class_name == "PaymentVerification":
            self.obj = obj.payment_verification_plan.get_program
            self.nested_field = "pk"

        elif self.class_name == "Program":
            self.obj = obj
            self.nested_field = "pk"

        elif self.class_name == "TargetPopulation":
            self.obj = obj.program
            self.nested_field = "pk"

        elif self.class_name == "RegistrationDataImport":
            self.obj = obj
            self.nested_field = "program_id"

        # TODO: update after changes for Ind and HH collections/representations
        # elif class_name == "Household":
        #     self.obj = obj
        #     self.nested_field = "program_id"
        #
        # elif class_name == "Individual":
        #     self.obj = obj
        #     self.nested_field = "program_id"
        else:
            raise ValueError(f"Can not found 'class_name' and 'nested_field' for class {self.class_name}")

    @property
    def get_id(self) -> Optional["UUID"]:
        return getattr(self.obj, self.nested_field, None)


@transaction.atomic
def activity_log_assign_program(apps, schema_editor) -> None:
    LogEntry = apps.get_model("activity_log", "LogEntry")

    log_qs = LogEntry.objects.all().exclude(programs__isnull=False)

    print(f"Found {log_qs.count()} Logs for assign to program")

    paginator = Paginator(log_qs, 1000)
    number_of_pages = paginator.num_pages

    for page in paginator.page_range:
        print(f"Loading page {page} of {number_of_pages}")

        for log in paginator.page(page).object_list:
            program_id = GetProgramId(log.content_object).get_id
            if program_id:
                log.programs.add(program_id)


class Migration(migrations.Migration):

    dependencies = [
        ('program', '0038_migration'),
        ('activity_log', '0001_migration_squashed_0004_migration'),
    ]

    operations = [
        migrations.AddField(
            model_name='logentry',
            name='programs',
            field=models.ManyToManyField(blank=True, related_name='activity_logs', to='program.Program'),
        ),
        migrations.RunPython(activity_log_assign_program, migrations.RunPython.noop),

    ]
