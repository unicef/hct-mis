schema {
  query: Query
  mutation: Mutations
}

type ActivateCashPlanVerificationMutation {
  cashPlan: CashPlanNode
}

type AdminAreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  parent: AdminAreaNode
  lft: Int!
  rght: Int!
  treeId: Int!
  level: Int!
  children(before: String, after: String, first: Int, last: Int, title: String): AdminAreaNodeConnection!
  householdSet(before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  programs(before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
}

type AdminAreaNodeConnection {
  pageInfo: PageInfo!
  edges: [AdminAreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type AdminAreaNodeEdge {
  node: AdminAreaNode
  cursor: String!
}

type AgeFilterObject {
  min: Int
  max: Int
}

input AgeInput {
  min: Int
  max: Int
}

type ApproveTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

scalar Arg

type BusinessAreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  name: String!
  longName: String!
  regionCode: String!
  regionName: String!
  koboToken: String
  rapidProHost: String
  rapidProApiKey: String
  slug: String!
  hasDataSharingAgreement: Boolean!
  userRoles: [UserRoleNode!]!
  householdSet(before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  paymentrecordSet(before: String, after: String, first: Int, last: Int, cashPlan: ID, household: ID): PaymentRecordNodeConnection!
  serviceproviderSet(before: String, after: String, first: Int, last: Int): ServiceProviderNodeConnection!
  programSet(before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  cashplanSet(before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  targetpopulationSet(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, businessArea: String, orderBy: String): TargetPopulationNodeConnection!
  registrationdataimportSet(before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
}

type BusinessAreaNodeConnection {
  pageInfo: PageInfo!
  edges: [BusinessAreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type BusinessAreaNodeEdge {
  node: BusinessAreaNode
  cursor: String!
}

type CashPlanNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  caId: String
  caHashId: UUID
  status: CashPlanStatus!
  statusDate: DateTime!
  name: String!
  distributionLevel: String!
  startDate: DateTime!
  endDate: DateTime!
  dispersionDate: DateTime!
  coverageDuration: Int!
  coverageUnit: String!
  comments: String
  program: ProgramNode!
  deliveryType: String!
  assistanceMeasurement: String!
  assistanceThrough: String!
  visionId: String!
  fundsCommitment: String!
  downPayment: String!
  validationAlertsCount: Int!
  totalPersonsCovered: Int!
  totalPersonsCoveredRevised: Int!
  totalEntitledQuantity: Float!
  totalEntitledQuantityRevised: Float!
  totalDeliveredQuantity: Float!
  totalUndeliveredQuantity: Float!
  verificationStatus: String!
  paymentRecords(before: String, after: String, first: Int, last: Int, cashPlan: ID, household: ID): PaymentRecordNodeConnection!
  verifications(before: String, after: String, first: Int, last: Int): CashPlanPaymentVerificationNodeConnection!
  bankReconciliationSuccess: Int
  bankReconciliationError: Int
}

type CashPlanNodeConnection {
  pageInfo: PageInfo!
  edges: [CashPlanNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type CashPlanNodeEdge {
  node: CashPlanNode
  cursor: String!
}

type CashPlanPaymentVerificationNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: CashPlanPaymentVerificationStatus!
  cashPlan: CashPlanNode!
  sampling: CashPlanPaymentVerificationSampling!
  verificationMethod: CashPlanPaymentVerificationVerificationMethod!
  sampleSize: Int
  respondedCount: Int
  receivedCount: Int
  notReceivedCount: Int
  receivedWithProblemsCount: Int
  confidenceInterval: Float
  marginOfError: Float
  rapidProFlowId: String!
  rapidProFlowStartUuid: String!
  ageFilter: AgeFilterObject
  excludedAdminAreasFilter: [String]
  sexFilter: String
  activationDate: DateTime
  completionDate: DateTime
  paymentRecordVerifications(before: String, after: String, first: Int, last: Int): PaymentVerificationNodeConnection!
}

type CashPlanPaymentVerificationNodeConnection {
  pageInfo: PageInfo!
  edges: [CashPlanPaymentVerificationNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type CashPlanPaymentVerificationNodeEdge {
  node: CashPlanPaymentVerificationNode
  cursor: String!
}

enum CashPlanPaymentVerificationSampling {
  FULL_LIST
  RANDOM
}

enum CashPlanPaymentVerificationStatus {
  PENDING
  ACTIVE
  FINISHED
}

enum CashPlanPaymentVerificationVerificationMethod {
  RAPIDPRO
  XLSX
  MANUAL
}

enum CashPlanStatus {
  DISTRIBUTION_COMPLETED
  DISTRIBUTION_COMPLETED_WITH_ERRORS
  TRANSACTION_COMPLETED
  TRANSACTION_COMPLETED_WITH_ERRORS
}

type CheckAgainstSanctionListMutation {
  ok: Boolean
  errors: [XlsxRowErrorNode]
}

type ChoiceObject {
  name: String
  value: String
}

input CopyTargetPopulationInput {
  id: ID
  name: String
}

input CopyTargetPopulationMutationInput {
  targetPopulationData: CopyTargetPopulationInput
  clientMutationId: String
}

type CopyTargetPopulationMutationPayload {
  targetPopulation: TargetPopulationNode
  clientMutationId: String
}

type CoreFieldChoiceObject {
  labels: [LabelNode]
  labelEn: String
  value: String
  admin: String
  listName: String
}

type CountAndPercentageNode {
  count: Int
  percentage: Float
}

input CreatePaymentVerificationInput {
  cashPlanId: ID!
  sampling: String!
  verificationChannel: String!
  businessAreaSlug: String!
  fullListArguments: FullListArguments
  randomSamplingArguments: RandomSamplingArguments
  rapidProArguments: RapidProArguments
}

type CreatePaymentVerificationMutation {
  cashPlan: CashPlanNode
}

type CreateProgram {
  program: ProgramNode
}

input CreateProgramInput {
  name: String
  startDate: Date
  endDate: Date
  description: String
  budget: Decimal
  frequencyOfPayments: String
  sector: String
  scope: String
  cashPlus: Boolean
  populationGoal: Int
  administrativeAreasOfImplementation: String
  businessAreaSlug: String
  individualDataNeeded: Boolean
}

input CreateTargetPopulationInput {
  name: String!
  targetingCriteria: TargetingCriteriaObjectType!
  businessAreaSlug: String!
}

type CreateTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

scalar Date

scalar DateTime

scalar Decimal

type DeduplicationResultNode {
  hitId: ID
  fullName: String
  score: Float
  proximityToScore: Float
  location: String
  age: Int
}

type DeleteProgram {
  ok: Boolean
}

type DeleteRegistrationDataImport {
  ok: Boolean
}

input DeleteTargetPopulationMutationInput {
  targetId: ID!
  clientMutationId: String
}

type DeleteTargetPopulationMutationPayload {
  ok: Boolean
  clientMutationId: String
}

type DiscardCashPlanVerificationMutation {
  cashPlan: CashPlanNode
}

type DjangoDebug {
  sql: [DjangoDebugSQL]
}

type DjangoDebugSQL {
  vendor: String!
  alias: String!
  sql: String
  duration: Float!
  rawSql: String!
  params: String!
  startTime: Float!
  stopTime: Float!
  isSlow: Boolean!
  isSelect: Boolean!
  transId: String
  transStatus: String
  isoLevel: String
  encoding: String
}

type DocumentNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  documentNumber: String!
  photo: String!
  individual: IndividualNode!
  type: DocumentTypeNode!
}

type DocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [DocumentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type DocumentNodeEdge {
  node: DocumentNode
  cursor: String!
}

type DocumentTypeNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  country: String
  label: String!
  type: DocumentTypeType!
  documents(before: String, after: String, first: Int, last: Int): DocumentNodeConnection!
}

enum DocumentTypeType {
  BIRTH_CERTIFICATE
  DRIVERS_LICENSE
  NATIONAL_ID
  NATIONAL_PASSPORT
  ELECTORAL_CARD
  OTHER
}

input EditCashPlanPaymentVerificationInput {
  cashPlanPaymentVerificationId: ID!
  sampling: String!
  verificationChannel: String!
  businessAreaSlug: String!
  fullListArguments: FullListArguments
  randomSamplingArguments: RandomSamplingArguments
  rapidProArguments: RapidProArguments
}

type EditPaymentVerificationMutation {
  cashPlan: CashPlanNode
}

type FieldAttributeNode {
  id: String
  type: String
  name: String
  labels: [LabelNode]
  labelEn: String
  hint: String
  required: Boolean
  choices: [CoreFieldChoiceObject]
  associatedWith: String
  isFlexField: Boolean
}

type FinalizeTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

type FinishCashPlanVerificationMutation {
  cashPlan: CashPlanNode
}

scalar FlexFieldsScalar

input FullListArguments {
  excludedAdminAreas: [String]
}

scalar GeoJSON

input GetCashplanVerificationSampleSizeInput {
  cashPlanId: ID!
  sampling: String!
  businessAreaSlug: String!
  fullListArguments: FullListArguments
  randomSamplingArguments: RandomSamplingArguments
}

type GetCashplanVerificationSampleSizeObject {
  paymentRecordCount: Int
  sampleSize: Int
}

type GroupAttributeNode {
  id: UUID!
  name: String!
  label: JSONString!
  flexAttributes(flexField: Boolean): [FieldAttributeNode]
  labelEn: String
}

type HouseholdNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSyncAt: DateTime
  status: HouseholdStatus!
  consent: String!
  residenceStatus: HouseholdResidenceStatus!
  countryOrigin: String
  country: String
  size: Int!
  address: String!
  adminArea: AdminAreaNode
  representatives(before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  geopoint: GeoJSON
  femaleAgeGroup05Count: Int!
  femaleAgeGroup611Count: Int!
  femaleAgeGroup1217Count: Int!
  femaleAdultsCount: Int!
  pregnantCount: Int!
  maleAgeGroup05Count: Int!
  maleAgeGroup611Count: Int!
  maleAgeGroup1217Count: Int!
  maleAdultsCount: Int!
  femaleAgeGroup05DisabledCount: Int!
  femaleAgeGroup611DisabledCount: Int!
  femaleAgeGroup1217DisabledCount: Int!
  femaleAdultsDisabledCount: Int!
  maleAgeGroup05DisabledCount: Int!
  maleAgeGroup611DisabledCount: Int!
  maleAgeGroup1217DisabledCount: Int!
  maleAdultsDisabledCount: Int!
  registrationDataImport: RegistrationDataImportNode!
  programs(before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  returnee: Boolean!
  flexFields: FlexFieldsScalar
  firstRegistrationDate: Date!
  lastRegistrationDate: Date!
  headOfHousehold: IndividualNode!
  unicefId: String!
  businessArea: UserBusinessAreaNode!
  individualsAndRoles: [IndividualRoleInHouseholdNode!]!
  individuals(before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  paymentRecords(before: String, after: String, first: Int, last: Int, cashPlan: ID, household: ID): PaymentRecordNodeConnection!
  targetPopulations(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, businessArea: String, orderBy: String): TargetPopulationNodeConnection!
  selections: [HouseholdSelection!]!
  totalCashReceived: Decimal
  selection: HouseholdSelection
  sanctionListPossibleMatch: Boolean
  hasDuplicates: Boolean
}

type HouseholdNodeConnection {
  pageInfo: PageInfo!
  edges: [HouseholdNodeEdge]!
  totalCount: Int
  individualsCount: Int
  edgeCount: Int
}

type HouseholdNodeEdge {
  node: HouseholdNode
  cursor: String!
}

enum HouseholdResidenceStatus {
  REFUGEE
  MIGRANT
  CITIZEN
  IDP
  OTHER
}

type HouseholdSelection {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode!
  targetPopulation: TargetPopulationNode!
  vulnerabilityScore: Float
  final: Boolean!
}

enum HouseholdStatus {
  ACTIVE
  INACTIVE
}

enum ImportDataDataType {
  XLSX
  JSON
}

type ImportDataNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  file: String!
  dataType: ImportDataDataType!
  numberOfHouseholds: Int!
  numberOfIndividuals: Int!
  registrationDataImport: RegistrationDataImportDatahubNode
}

type ImportXlsxCashPlanVerification {
  cashPlan: CashPlanNode
  errors: [XlsxErrorNode]
}

type ImportedDocumentNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  documentNumber: String!
  photo: String!
  individual: ImportedIndividualNode!
  type: ImportedDocumentTypeNode!
}

type ImportedDocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedDocumentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedDocumentNodeEdge {
  node: ImportedDocumentNode
  cursor: String!
}

enum ImportedDocumentTypeCountry {
  AF
  AX
  AL
  DZ
  AS
  AD
  AO
  AI
  AQ
  AG
  AR
  AM
  AW
  AU
  AT
  AZ
  BS
  BH
  BD
  BB
  BY
  BE
  BZ
  BJ
  BM
  BT
  BO
  BQ
  BA
  BW
  BV
  BR
  IO
  BN
  BG
  BF
  BI
  CV
  KH
  CM
  CA
  KY
  CF
  TD
  CL
  CN
  CX
  CC
  CO
  KM
  CG
  CD
  CK
  CR
  CI
  HR
  CU
  CW
  CY
  CZ
  DK
  DJ
  DM
  DO
  EC
  EG
  SV
  GQ
  ER
  EE
  SZ
  ET
  FK
  FO
  FJ
  FI
  FR
  GF
  PF
  TF
  GA
  GM
  GE
  DE
  GH
  GI
  GR
  GL
  GD
  GP
  GU
  GT
  GG
  GN
  GW
  GY
  HT
  HM
  VA
  HN
  HK
  HU
  IS
  IN
  ID
  IR
  IQ
  IE
  IM
  IL
  IT
  JM
  JP
  JE
  JO
  KZ
  KE
  KI
  KW
  KG
  LA
  LV
  LB
  LS
  LR
  LY
  LI
  LT
  LU
  MO
  MG
  MW
  MY
  MV
  ML
  MT
  MH
  MQ
  MR
  MU
  YT
  MX
  FM
  MD
  MC
  MN
  ME
  MS
  MA
  MZ
  MM
  NA
  NR
  NP
  NL
  NC
  NZ
  NI
  NE
  NG
  NU
  NF
  KP
  MK
  MP
  NO
  OM
  PK
  PW
  PS
  PA
  PG
  PY
  PE
  PH
  PN
  PL
  PT
  PR
  QA
  RE
  RO
  RU
  RW
  BL
  SH
  KN
  LC
  MF
  PM
  VC
  WS
  SM
  ST
  SA
  SN
  RS
  SC
  SL
  SG
  SX
  SK
  SI
  SB
  SO
  ZA
  GS
  KR
  SS
  ES
  LK
  SD
  SR
  SJ
  SE
  CH
  SY
  TW
  TJ
  TZ
  TH
  TL
  TG
  TK
  TO
  TT
  TN
  TR
  TM
  TC
  TV
  UG
  UA
  AE
  GB
  UM
  US
  UY
  UZ
  VU
  VE
  VN
  VG
  VI
  WF
  EH
  YE
  ZM
  ZW
}

type ImportedDocumentTypeNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  country: ImportedDocumentTypeCountry
  label: String!
  type: ImportedDocumentTypeType!
  documents(before: String, after: String, first: Int, last: Int): ImportedDocumentNodeConnection!
}

enum ImportedDocumentTypeType {
  BIRTH_CERTIFICATE
  DRIVERS_LICENSE
  NATIONAL_ID
  NATIONAL_PASSPORT
  ELECTORAL_CARD
  OTHER
}

type ImportedHouseholdNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  consent: String!
  residenceStatus: ImportedHouseholdResidenceStatus!
  countryOrigin: String
  size: Int!
  address: String!
  country: String
  admin1: String!
  admin2: String!
  geopoint: GeoJSON
  femaleAgeGroup05Count: Int!
  femaleAgeGroup611Count: Int!
  femaleAgeGroup1217Count: Int!
  femaleAdultsCount: Int!
  pregnantCount: Int!
  maleAgeGroup05Count: Int!
  maleAgeGroup611Count: Int!
  maleAgeGroup1217Count: Int!
  maleAdultsCount: Int!
  femaleAgeGroup05DisabledCount: Int!
  femaleAgeGroup611DisabledCount: Int!
  femaleAgeGroup1217DisabledCount: Int!
  femaleAdultsDisabledCount: Int!
  maleAgeGroup05DisabledCount: Int!
  maleAgeGroup611DisabledCount: Int!
  maleAgeGroup1217DisabledCount: Int!
  maleAdultsDisabledCount: Int!
  headOfHousehold: ImportedIndividualNode
  registrationDataImport: RegistrationDataImportDatahubNode!
  firstRegistrationDate: Date!
  lastRegistrationDate: Date!
  returnee: Boolean!
  flexFields: JSONString!
  individuals(before: String, after: String, first: Int, last: Int): ImportedIndividualNodeConnection!
  hasDuplicates: Boolean
}

type ImportedHouseholdNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedHouseholdNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedHouseholdNodeEdge {
  node: ImportedHouseholdNode
  cursor: String!
}

enum ImportedHouseholdResidenceStatus {
  REFUGEE
  MIGRANT
  CITIZEN
  IDP
  OTHER
}

enum ImportedIndividualDeduplicationBatchStatus {
  SIMILAR_IN_BATCH
  DUPLICATE_IN_BATCH
  UNIQUE_IN_BATCH
  NOT_PROCESSED
}

enum ImportedIndividualDeduplicationGoldenRecordStatus {
  UNIQUE
  DUPLICATE
  NEEDS_ADJUDICATION
  NOT_PROCESSED
}

type ImportedIndividualIdentityNode {
  id: ID!
  individual: ImportedIndividualNode!
  documentNumber: String!
  type: String
}

enum ImportedIndividualMaritalStatus {
  SINGLE
  MARRIED
  WIDOW
  DIVORCED
  SEPARATED
}

type ImportedIndividualNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  individualId: String!
  photo: String!
  fullName: String!
  givenName: String!
  middleName: String!
  familyName: String!
  relationship: String
  sex: ImportedIndividualSex!
  birthDate: Date!
  estimatedBirthDate: Boolean
  maritalStatus: ImportedIndividualMaritalStatus!
  phoneNo: String!
  phoneNoAlternative: String!
  household: ImportedHouseholdNode
  registrationDataImport: RegistrationDataImportDatahubNode!
  disability: Boolean!
  workStatus: ImportedIndividualWorkStatus
  firstRegistrationDate: Date!
  lastRegistrationDate: Date!
  deduplicationBatchStatus: ImportedIndividualDeduplicationBatchStatus
  deduplicationGoldenRecordStatus: ImportedIndividualDeduplicationGoldenRecordStatus
  deduplicationBatchResults: [DeduplicationResultNode]
  deduplicationGoldenRecordResults: [DeduplicationResultNode]
  flexFields: JSONString!
  pregnant: Boolean!
  importedhousehold: ImportedHouseholdNode
  documents(before: String, after: String, first: Int, last: Int): ImportedDocumentNodeConnection!
  identities: [ImportedIndividualIdentityNode!]!
  role: String
}

type ImportedIndividualNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedIndividualNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedIndividualNodeEdge {
  node: ImportedIndividualNode
  cursor: String!
}

enum ImportedIndividualSex {
  MALE
  FEMALE
}

enum ImportedIndividualWorkStatus {
  YES
  NO
  NOT_PROVIDED
}

enum IndividualDeduplicationBatchStatus {
  SIMILAR_IN_BATCH
  DUPLICATE_IN_BATCH
  UNIQUE_IN_BATCH
  NOT_PROCESSED
}

enum IndividualDeduplicationGoldenRecordStatus {
  UNIQUE
  DUPLICATE
  NEEDS_ADJUDICATION
  NOT_PROCESSED
}

type IndividualIdentityNode {
  id: ID!
  individual: IndividualNode!
  number: String!
  type: String
}

enum IndividualMaritalStatus {
  SINGLE
  MARRIED
  WIDOW
  DIVORCED
  SEPARATED
}

type IndividualNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSyncAt: DateTime
  status: IndividualStatus!
  individualId: String!
  photo: String!
  fullName: String!
  givenName: String!
  middleName: String!
  familyName: String!
  sex: IndividualSex!
  birthDate: Date!
  estimatedBirthDate: Boolean
  maritalStatus: IndividualMaritalStatus!
  phoneNo: String!
  phoneNoAlternative: String!
  relationship: IndividualRelationship
  household: HouseholdNode
  registrationDataImport: RegistrationDataImportNode!
  disability: Boolean!
  workStatus: IndividualWorkStatus
  firstRegistrationDate: Date!
  lastRegistrationDate: Date!
  flexFields: FlexFieldsScalar
  enrolledInNutritionProgramme: Boolean!
  administrationOfRutf: Boolean!
  unicefId: String!
  deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus!
  deduplicationBatchStatus: IndividualDeduplicationBatchStatus!
  deduplicationGoldenRecordResults: [DeduplicationResultNode]
  deduplicationBatchResults: [DeduplicationResultNode]
  importedIndividualId: UUID
  sanctionListPossibleMatch: Boolean!
  sanctionListLastCheck: DateTime
  pregnant: Boolean!
  representedHouseholds(before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  headingHousehold: HouseholdNode
  documents(before: String, after: String, first: Int, last: Int): DocumentNodeConnection!
  identities: [IndividualIdentityNode!]!
  householdsAndRoles: [IndividualRoleInHouseholdNode!]!
  role: String
}

type IndividualNodeConnection {
  pageInfo: PageInfo!
  edges: [IndividualNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type IndividualNodeEdge {
  node: IndividualNode
  cursor: String!
}

enum IndividualRelationship {
  NON_BENEFICIARY
  HEAD
  SON_DAUGHTER
  WIFE_HUSBAND
  BROTHER_SISTER
  MOTHER_FATHER
  AUNT_UNCLE
  GRANDMOTHER_GRANDFATHER
  MOTHERINLAW_FATHERINLAW
  DAUGHTERINLAW_SONINLAW
  SISTERINLAW_BROTHERINLAW
  GRANDDAUGHER_GRANDSON
  NEPHEW_NIECE
  COUSIN
}

type IndividualRoleInHouseholdNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSyncAt: DateTime
  individual: IndividualNode!
  household: HouseholdNode!
  role: IndividualRoleInHouseholdRole
}

enum IndividualRoleInHouseholdRole {
  PRIMARY
  ALTERNATE
  NO_ROLE
}

enum IndividualSex {
  MALE
  FEMALE
}

enum IndividualStatus {
  ACTIVE
  INACTIVE
}

enum IndividualWorkStatus {
  YES
  NO
  NOT_PROVIDED
}

scalar JSONLazyString

scalar JSONString

type KoboAssetObject {
  id: String
  name: String
  sector: String
  country: String
  assetType: String
  dateModified: DateTime
  deploymentActive: Boolean
  hasDeployment: Boolean
  xlsLink: String
}

type KoboAssetObjectConnection {
  pageInfo: PageInfo!
  edges: [KoboAssetObjectEdge]!
  totalCount: Int
}

type KoboAssetObjectEdge {
  node: KoboAssetObject
  cursor: String!
}

type KoboErrorNode {
  header: String
  message: String
}

type LabelNode {
  language: String
  label: String
}

enum LogEntryAction {
  A_0
  A_1
  A_2
}

type LogEntryObject {
  id: ID!
  objectPk: String!
  objectId: Int
  objectRepr: String!
  action: LogEntryAction!
  changes: String!
  actor: UserNode
  remoteAddr: String
  timestamp: DateTime
  changesDisplayDict: JSONLazyString
}

type LogEntryObjectConnection {
  pageInfo: PageInfo!
  edges: [LogEntryObjectEdge]!
  totalCount: Int
}

type LogEntryObjectEdge {
  node: LogEntryObject
  cursor: String!
}

type MergeRegistrationDataImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

type Mutations {
  createCashPlanPaymentVerification(input: CreatePaymentVerificationInput!): CreatePaymentVerificationMutation
  editCashPlanPaymentVerification(input: EditCashPlanPaymentVerificationInput!): EditPaymentVerificationMutation
  importXlsxCashPlanVerification(cashPlanVerificationId: ID!, file: Upload!): ImportXlsxCashPlanVerification
  activateCashPlanPaymentVerification(cashPlanVerificationId: ID!): ActivateCashPlanVerificationMutation
  finishCashPlanPaymentVerification(cashPlanVerificationId: ID!): FinishCashPlanVerificationMutation
  discardCashPlanPaymentVerification(cashPlanVerificationId: ID!): DiscardCashPlanVerificationMutation
  updatePaymentVerificationStatusAndReceivedAmount(paymentVerificationId: ID!, receivedAmount: Decimal!, status: PaymentVerificationStatusForUpdate): UpdatePaymentVerificationStatusAndReceivedAmount
  updatePaymentVerificationReceivedAndReceivedAmount(paymentVerificationId: ID!, received: Boolean!, receivedAmount: Decimal!): UpdatePaymentVerificationReceivedAndReceivedAmount
  createTargetPopulation(input: CreateTargetPopulationInput!): CreateTargetPopulationMutation
  updateTargetPopulation(input: UpdateTargetPopulationInput!): UpdateTargetPopulationMutation
  copyTargetPopulation(input: CopyTargetPopulationMutationInput!): CopyTargetPopulationMutationPayload
  deleteTargetPopulation(input: DeleteTargetPopulationMutationInput!): DeleteTargetPopulationMutationPayload
  approveTargetPopulation(id: ID!, programId: ID!): ApproveTargetPopulationMutation
  unapproveTargetPopulation(id: ID!): UnapproveTargetPopulationMutation
  finalizeTargetPopulation(id: ID!): FinalizeTargetPopulationMutation
  createProgram(programData: CreateProgramInput!): CreateProgram
  updateProgram(programData: UpdateProgramInput): UpdateProgram
  deleteProgram(programId: String!): DeleteProgram
  uploadImportDataXlsxFile(businessAreaSlug: String!, file: Upload!): UploadImportDataXLSXFile
  deleteRegistrationDataImport(registrationDataImportId: String!): DeleteRegistrationDataImport
  registrationXlsxImport(registrationDataImportData: RegistrationXlsxImportMutationInput!): RegistrationXlsxImportMutation
  registrationKoboImport(registrationDataImportData: RegistrationKoboImportMutationInput!): RegistrationKoboImportMutation
  saveKoboImportData(businessAreaSlug: String!, uid: Upload!): SaveKoboProjectImportDataMutation
  mergeRegistrationDataImport(id: ID!): MergeRegistrationDataImportMutation
  rerunDedupe(registrationDataImportDatahubId: ID!): RegistrationDeduplicationMutation
  checkAgainstSanctionList(file: Upload!): CheckAgainstSanctionListMutation
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum PaymentRecordDeliveryType {
  CASH
  DEPOSIT_TO_CARD
  TRANSFER
}

enum PaymentRecordEntitlementCardStatus {
  ACTIVE
  INACTIVE
}

type PaymentRecordNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  status: PaymentRecordStatus!
  statusDate: DateTime!
  caId: String
  caHashId: UUID
  cashPlan: CashPlanNode
  household: HouseholdNode!
  fullName: String!
  totalPersonsCovered: Int!
  distributionModality: String!
  targetPopulation: TargetPopulationNode!
  targetPopulationCashAssistId: String!
  entitlementCardNumber: String!
  entitlementCardStatus: PaymentRecordEntitlementCardStatus!
  entitlementCardIssueDate: Date!
  deliveryType: PaymentRecordDeliveryType!
  currency: String!
  entitlementQuantity: Float!
  deliveredQuantity: Float!
  deliveryDate: DateTime!
  serviceProvider: ServiceProviderNode!
  transactionReferenceId: String
  visionId: String
  verifications(before: String, after: String, first: Int, last: Int): PaymentVerificationNodeConnection!
}

type PaymentRecordNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentRecordNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentRecordNodeEdge {
  node: PaymentRecordNode
  cursor: String!
}

enum PaymentRecordStatus {
  SUCCESS
  PENDING
  ERROR
}

type PaymentVerificationNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  cashPlanPaymentVerification: CashPlanPaymentVerificationNode!
  paymentRecord: PaymentRecordNode!
  status: PaymentVerificationStatus!
  statusDate: Date
  receivedAmount: Float
}

type PaymentVerificationNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentVerificationNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentVerificationNodeEdge {
  node: PaymentVerificationNode
  cursor: String!
}

enum PaymentVerificationStatus {
  PENDING
  RECEIVED
  NOT_RECEIVED
  RECEIVED_WITH_ISSUES
}

enum PaymentVerificationStatusForUpdate {
  PENDING
  RECEIVED
  NOT_RECEIVED
  RECEIVED_WITH_ISSUES
}

enum ProgramFrequencyOfPayments {
  REGULAR
  ONE_OFF
}

type ProgramNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSyncAt: DateTime
  name: String!
  status: ProgramStatus!
  startDate: Date!
  endDate: Date!
  description: String!
  caId: String
  caHashId: String
  adminAreas(before: String, after: String, first: Int, last: Int, title: String): AdminAreaNodeConnection!
  businessArea: UserBusinessAreaNode!
  budget: Decimal
  frequencyOfPayments: ProgramFrequencyOfPayments!
  sector: ProgramSector!
  scope: ProgramScope!
  cashPlus: Boolean!
  populationGoal: Int!
  administrativeAreasOfImplementation: String!
  individualDataNeeded: Boolean
  households(before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  cashPlans(before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  targetpopulationSet(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, businessArea: String, orderBy: String): TargetPopulationNodeConnection!
  totalEntitledQuantity: Decimal
  totalDeliveredQuantity: Decimal
  totalUndeliveredQuantity: Decimal
  totalNumberOfHouseholds: Int
  history(before: String, after: String, first: Int, last: Int): LogEntryObjectConnection
}

type ProgramNodeConnection {
  pageInfo: PageInfo!
  edges: [ProgramNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ProgramNodeEdge {
  node: ProgramNode
  cursor: String!
}

enum ProgramScope {
  FOR_PARTNERS
  UNICEF
}

enum ProgramSector {
  CHILD_PROTECTION
  EDUCATION
  HEALTH
  MULTI_PURPOSE
  NUTRITION
  SOCIAL_POLICY
  WASH
}

enum ProgramStatus {
  DRAFT
  ACTIVE
  FINISHED
}

type Query {
  paymentRecord(id: ID!): PaymentRecordNode
  paymentRecordVerification(id: ID!): PaymentVerificationNode
  allPaymentRecords(before: String, after: String, first: Int, last: Int, cashPlan: ID, household: ID, orderBy: String): PaymentRecordNodeConnection
  allPaymentVerifications(before: String, after: String, first: Int, last: Int, cashPlanPaymentVerification: ID, status: String, search: String, orderBy: String): PaymentVerificationNodeConnection
  paymentRecordStatusChoices: [ChoiceObject]
  paymentRecordEntitlementCardStatusChoices: [ChoiceObject]
  paymentRecordDeliveryTypeChoices: [ChoiceObject]
  cashPlanVerificationStatusChoices: [ChoiceObject]
  cashPlanVerificationSamplingChoices: [ChoiceObject]
  cashPlanVerificationVerificationMethodChoices: [ChoiceObject]
  paymentVerificationStatusChoices: [ChoiceObject]
  allRapidProFlows(businessAreaSlug: String!): [RapidProFlow]
  sampleSize(input: GetCashplanVerificationSampleSizeInput): GetCashplanVerificationSampleSizeObject
  adminArea(id: ID!): AdminAreaNode
  allAdminAreas(before: String, after: String, first: Int, last: Int, title: String, title_Icontains: String, businessArea: String): AdminAreaNodeConnection
  allBusinessAreas(before: String, after: String, first: Int, last: Int, id: UUID): BusinessAreaNodeConnection
  allFieldsAttributes(flexField: Boolean): [FieldAttributeNode]
  allGroupsWithFields: [GroupAttributeNode]
  koboProject(uid: String!, businessAreaSlug: String!): KoboAssetObject
  allKoboProjects(businessAreaSlug: String!, onlyDeployed: Boolean, before: String, after: String, first: Int, last: Int): KoboAssetObjectConnection
  cashAssistUrlPrefix: String
  program(id: ID!): ProgramNode
  allPrograms(before: String, after: String, first: Int, last: Int, businessArea: String!, search: String, status: [String], sector: [String], numberOfHouseholds: String, budget: String, startDate: Date, endDate: Date, orderBy: String): ProgramNodeConnection
  cashPlan(id: ID!): CashPlanNode
  allCashPlans(before: String, after: String, first: Int, last: Int, program: ID, verificationStatus: String, assistanceThrough: String, assistanceThrough_Icontains: String, deliveryType: String, startDate: DateTime, startDate_Lte: DateTime, startDate_Gte: DateTime, endDate: DateTime, endDate_Lte: DateTime, endDate_Gte: DateTime, search: String, orderBy: String): CashPlanNodeConnection
  programStatusChoices: [ChoiceObject]
  programFrequencyOfPaymentsChoices: [ChoiceObject]
  programSectorChoices: [ChoiceObject]
  programScopeChoices: [ChoiceObject]
  cashPlanStatusChoices: [ChoiceObject]
  targetPopulation(id: ID!): TargetPopulationNode
  allTargetPopulation(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, businessArea: String, orderBy: String): TargetPopulationNodeConnection
  goldenRecordByTargetingCriteria(targetingCriteria: TargetingCriteriaObjectType!, before: String, after: String, first: Int, last: Int, orderBy: String): HouseholdNodeConnection
  candidateHouseholdsListByTargetingCriteria(targetPopulation: ID!, before: String, after: String, first: Int, last: Int, orderBy: String): HouseholdNodeConnection
  finalHouseholdsListByTargetingCriteria(targetPopulation: ID!, targetingCriteria: TargetingCriteriaObjectType, before: String, after: String, first: Int, last: Int, orderBy: String): HouseholdNodeConnection
  targetPopulationStatusChoices: [ChoiceObject]
  household(id: ID!): HouseholdNode
  allHouseholds(before: String, after: String, first: Int, last: Int, businessArea: String, countryOrigin: String, countryOrigin_Icontains: String, address: String, address_Icontains: String, headOfHousehold_FullName: String, headOfHousehold_FullName_Icontains: String, size_Range: Int, size_Lte: Int, size_Gte: Int, adminArea: ID, targetPopulations: [ID], programs: [ID], residenceStatus: String, size: String, search: String, orderBy: String): HouseholdNodeConnection
  individual(id: ID!): IndividualNode
  allIndividuals(before: String, after: String, first: Int, last: Int, programme: String, businessArea: String, fullName: String, fullName_Icontains: String, sex: [String], age: String, search: String, orderBy: String): IndividualNodeConnection
  residenceStatusChoices: [ChoiceObject]
  sexChoices: [ChoiceObject]
  maritalStatusChoices: [ChoiceObject]
  relationshipChoices: [ChoiceObject]
  roleChoices: [ChoiceObject]
  me: UserObjectType
  allUsers(before: String, after: String, first: Int, last: Int, search: String, status: [String], partner: [String], roles: [String], businessArea: String!, orderBy: String): UserNodeConnection
  allLogEntries(objectId: String!, before: String, after: String, first: Int, last: Int): LogEntryObjectConnection
  userRolesChoices: [ChoiceObject]
  userStatusChoices: [ChoiceObject]
  userPartnerChoices: [ChoiceObject]
  hasAvailableUsersToExport(businessAreaSlug: String!): Boolean
  importedHousehold(id: ID!): ImportedHouseholdNode
  allImportedHouseholds(before: String, after: String, first: Int, last: Int, rdiId: String, orderBy: String): ImportedHouseholdNodeConnection
  registrationDataImportDatahub(id: ID!): RegistrationDataImportDatahubNode
  allRegistrationDataImportsDatahub(before: String, after: String, first: Int, last: Int): RegistrationDataImportDatahubNodeConnection
  importedIndividual(id: ID!): ImportedIndividualNode
  allImportedIndividuals(before: String, after: String, first: Int, last: Int, household: ID, rdiId: String, duplicatesOnly: Boolean, orderBy: String): ImportedIndividualNodeConnection
  importData(id: ID!): ImportDataNode
  deduplicationBatchStatusChoices: [ChoiceObject]
  deduplicationGoldenRecordStatusChoices: [ChoiceObject]
  registrationDataImport(id: ID!): RegistrationDataImportNode
  allRegistrationDataImports(before: String, after: String, first: Int, last: Int, importedBy_Id: UUID, importDate: Date, status: String, name: String, name_Icontains: String, businessArea: String, orderBy: String): RegistrationDataImportNodeConnection
  registrationDataStatusChoices: [ChoiceObject]
  _debug: DjangoDebug
}

input RandomSamplingArguments {
  confidenceInterval: Float!
  marginOfError: Float!
  excludedAdminAreas: [String]
  age: AgeInput
  sex: String
}

input RapidProArguments {
  flowId: String!
}

type RapidProFlow {
  id: String
  name: String
  type: String
  archived: Boolean
  labels: [String]
  expires: Int
  runs: [RapidProFlowRun]
  results: [RapidProFlowResult]
  createdOn: DateTime
  modifiedOn: DateTime
}

type RapidProFlowResult {
  key: String
  name: String
  categories: [String]
  nodeUuids: [String]
}

type RapidProFlowRun {
  active: Int
  completed: Int
  interrupted: Int
  expired: Int
}

enum RegistrationDataImportDataSource {
  XLS
  KOBO
}

enum RegistrationDataImportDatahubImportDone {
  NOT_STARTED
  STARTED
  DONE
}

type RegistrationDataImportDatahubNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  importDate: DateTime!
  hctId: UUID
  importData: ImportDataNode
  importDone: RegistrationDataImportDatahubImportDone!
  businessAreaSlug: String!
  households(before: String, after: String, first: Int, last: Int): ImportedHouseholdNodeConnection!
  individuals(before: String, after: String, first: Int, last: Int): ImportedIndividualNodeConnection!
}

type RegistrationDataImportDatahubNodeConnection {
  pageInfo: PageInfo!
  edges: [RegistrationDataImportDatahubNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RegistrationDataImportDatahubNodeEdge {
  node: RegistrationDataImportDatahubNode
  cursor: String!
}

type RegistrationDataImportNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  status: RegistrationDataImportStatus!
  importDate: DateTime!
  importedBy: UserNode!
  dataSource: RegistrationDataImportDataSource!
  numberOfIndividuals: Int!
  numberOfHouseholds: Int!
  datahubId: UUID
  errorMessage: String!
  businessArea: UserBusinessAreaNode
  households(before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individuals(before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  batchDuplicatesCountAndPercentage: CountAndPercentageNode
  goldenRecordDuplicatesCountAndPercentage: CountAndPercentageNode
  batchPossibleDuplicatesCountAndPercentage: CountAndPercentageNode
  goldenRecordPossibleDuplicatesCountAndPercentage: CountAndPercentageNode
  batchUniqueCountAndPercentage: CountAndPercentageNode
  goldenRecordUniqueCountAndPercentage: CountAndPercentageNode
}

type RegistrationDataImportNodeConnection {
  pageInfo: PageInfo!
  edges: [RegistrationDataImportNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RegistrationDataImportNodeEdge {
  node: RegistrationDataImportNode
  cursor: String!
}

enum RegistrationDataImportStatus {
  IN_REVIEW
  MERGED
  MERGING
  IMPORTING
  DEDUPLICATION_FAILED
  DEDUPLICATION
}

type RegistrationDeduplicationMutation {
  ok: Boolean
}

type RegistrationKoboImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

input RegistrationKoboImportMutationInput {
  importDataId: String
  name: String
  businessAreaSlug: String
}

type RegistrationXlsxImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

input RegistrationXlsxImportMutationInput {
  importDataId: ID
  name: String
  businessAreaSlug: String
}

type RoleNode {
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  permissions: [String]!
  userRoles: [UserRoleNode!]!
}

type SaveKoboProjectImportDataMutation {
  importData: ImportDataNode
  errors: [KoboErrorNode]
}

type ServiceProviderNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  caId: String!
  fullName: String!
  shortName: String!
  country: String!
  visionId: String!
  paymentRecords(before: String, after: String, first: Int, last: Int, cashPlan: ID, household: ID): PaymentRecordNodeConnection!
}

type ServiceProviderNodeConnection {
  pageInfo: PageInfo!
  edges: [ServiceProviderNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ServiceProviderNodeEdge {
  node: ServiceProviderNode
  cursor: String!
}

type StatsObjectType {
  childMale: Int
  childFemale: Int
  adultMale: Int
  adultFemale: Int
}

type TargetPopulationNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  isRemoved: Boolean!
  name: String!
  caId: String
  caHashId: String
  createdBy: UserNode
  approvedAt: DateTime
  approvedBy: UserNode
  finalizedAt: DateTime
  finalizedBy: UserNode
  businessArea: UserBusinessAreaNode
  status: TargetPopulationStatus!
  households(before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  candidateListTotalHouseholds: Int
  candidateListTotalIndividuals: Int
  finalListTotalHouseholds: Int
  finalListTotalIndividuals: Int
  selectionComputationMetadata: String
  program: ProgramNode
  candidateListTargetingCriteria: TargetingCriteriaNode
  finalListTargetingCriteria: TargetingCriteriaNode
  sentToDatahub: Boolean!
  paymentRecords(before: String, after: String, first: Int, last: Int, cashPlan: ID, household: ID): PaymentRecordNodeConnection!
  selections: [HouseholdSelection!]!
  totalHouseholds: Int
  totalFamilySize: Int
  finalList(before: String, after: String, first: Int, last: Int): HouseholdNodeConnection
  candidateStats: StatsObjectType
  finalStats: StatsObjectType
}

type TargetPopulationNodeConnection {
  pageInfo: PageInfo!
  edges: [TargetPopulationNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TargetPopulationNodeEdge {
  node: TargetPopulationNode
  cursor: String!
}

enum TargetPopulationStatus {
  DRAFT
  APPROVED
  FINALIZED
}

type TargetingCriteriaNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  targetPopulationCandidate: TargetPopulationNode
  targetPopulationFinal: TargetPopulationNode
  rules: [TargetingCriteriaRuleNode]
}

input TargetingCriteriaObjectType {
  rules: [TargetingCriteriaRuleObjectType]
}

enum TargetingCriteriaRuleFilterComparisionMethod {
  EQUALS
  NOT_EQUALS
  CONTAINS
  NOT_CONTAINS
  RANGE
  NOT_IN_RANGE
  GREATER_THAN
  LESS_THAN
}

type TargetingCriteriaRuleFilterNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  comparisionMethod: TargetingCriteriaRuleFilterComparisionMethod!
  targetingCriteriaRule: TargetingCriteriaRuleNode!
  isFlexField: Boolean!
  fieldName: String!
  arguments: [Arg]
  fieldAttribute: FieldAttributeNode
}

input TargetingCriteriaRuleFilterObjectType {
  comparisionMethod: String!
  isFlexField: Boolean!
  fieldName: String!
  arguments: [Arg]!
}

type TargetingCriteriaRuleNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  targetingCriteria: TargetingCriteriaNode!
  filters: [TargetingCriteriaRuleFilterNode]
}

input TargetingCriteriaRuleObjectType {
  filters: [TargetingCriteriaRuleFilterObjectType]
}

scalar UUID

type UnapproveTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

type UpdatePaymentVerificationReceivedAndReceivedAmount {
  paymentVerification: PaymentVerificationNode
}

type UpdatePaymentVerificationStatusAndReceivedAmount {
  paymentVerification: PaymentVerificationNode
}

type UpdateProgram {
  program: ProgramNode
}

input UpdateProgramInput {
  id: String!
  name: String
  status: String
  startDate: Date
  endDate: Date
  description: String
  budget: Decimal
  frequencyOfPayments: String
  sector: String
  scope: String
  cashPlus: Boolean
  populationGoal: Int
  administrativeAreasOfImplementation: String
  businessAreaSlug: String
  individualDataNeeded: Boolean
}

input UpdateTargetPopulationInput {
  id: ID!
  name: String
  targetingCriteria: TargetingCriteriaObjectType
}

type UpdateTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

scalar Upload

type UploadImportDataXLSXFile {
  importData: ImportDataNode
  errors: [XlsxRowErrorNode]
}

type UserBusinessAreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  name: String!
  longName: String!
  regionCode: String!
  regionName: String!
  koboToken: String
  rapidProHost: String
  rapidProApiKey: String
  slug: String!
  hasDataSharingAgreement: Boolean!
  userRoles: [UserRoleNode!]!
  householdSet(before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  paymentrecordSet(before: String, after: String, first: Int, last: Int, cashPlan: ID, household: ID): PaymentRecordNodeConnection!
  serviceproviderSet(before: String, after: String, first: Int, last: Int): ServiceProviderNodeConnection!
  programSet(before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  cashplanSet(before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  targetpopulationSet(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, businessArea: String, orderBy: String): TargetPopulationNodeConnection!
  registrationdataimportSet(before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  permissions: [String]
}

type UserBusinessAreaNodeConnection {
  pageInfo: PageInfo!
  edges: [UserBusinessAreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type UserBusinessAreaNodeEdge {
  node: UserBusinessAreaNode
  cursor: String!
}

type UserNode implements Node {
  id: ID!
  lastLogin: DateTime
  isSuperuser: Boolean!
  username: String!
  firstName: String!
  lastName: String!
  email: String!
  isStaff: Boolean!
  isActive: Boolean!
  dateJoined: DateTime!
  status: UserStatus!
  partner: UserPartner!
  availableForExport: Boolean!
  userRoles: [UserRoleNode!]!
  targetPopulations(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, businessArea: String, orderBy: String): TargetPopulationNodeConnection!
  approvedTargetPopulations(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, businessArea: String, orderBy: String): TargetPopulationNodeConnection!
  finalizedTargetPopulations(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, businessArea: String, orderBy: String): TargetPopulationNodeConnection!
  registrationDataImports(before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  businessAreas(before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection
}

type UserNodeConnection {
  pageInfo: PageInfo!
  edges: [UserNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type UserNodeEdge {
  node: UserNode
  cursor: String!
}

type UserObjectType {
  id: UUID!
  lastLogin: DateTime
  isSuperuser: Boolean!
  username: String!
  firstName: String!
  lastName: String!
  email: String!
  isStaff: Boolean!
  isActive: Boolean!
  dateJoined: DateTime!
  status: UserStatus!
  partner: UserPartner!
  availableForExport: Boolean!
  userRoles: [UserRoleNode!]!
  targetPopulations(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, businessArea: String, orderBy: String): TargetPopulationNodeConnection!
  approvedTargetPopulations(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, businessArea: String, orderBy: String): TargetPopulationNodeConnection!
  finalizedTargetPopulations(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, businessArea: String, orderBy: String): TargetPopulationNodeConnection!
  registrationDataImports(before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  businessAreas(before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection
}

enum UserPartner {
  UNHCR
  WFP
  UNICEF
}

type UserRoleNode {
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  role: RoleNode!
}

enum UserStatus {
  INVITED
  ACTIVE
  INACTIVE
}

type XlsxErrorNode {
  sheet: String
  coordinates: String
  message: String
}

type XlsxRowErrorNode {
  rowNumber: Int
  header: String
  message: String
}
