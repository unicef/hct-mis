schema {
  query: Query
  mutation: Mutations
}

type AdminAreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  parent: AdminAreaNode
  lft: Int!
  rght: Int!
  treeId: Int!
  level: Int!
  children(before: String, after: String, first: Int, last: Int, title: String): AdminAreaNodeConnection!
  householdSet(before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  programs(before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
}

type AdminAreaNodeConnection {
  pageInfo: PageInfo!
  edges: [AdminAreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type AdminAreaNodeEdge {
  node: AdminAreaNode
  cursor: String!
}

type ApproveRegistrationDataImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

type ApproveTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

scalar Arg

type BusinessAreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  name: String!
  longName: String!
  regionCode: String!
  regionName: String!
  koboToken: String
  slug: String!
  userSet(before: String, after: String, first: Int, last: Int): UserNodeConnection!
  programSet(before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  registrationdataimportSet(before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
}

type BusinessAreaNodeConnection {
  pageInfo: PageInfo!
  edges: [BusinessAreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type BusinessAreaNodeEdge {
  node: BusinessAreaNode
  cursor: String!
}

type CashPlanNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  program: ProgramNode!
  name: String!
  startDate: DateTime!
  endDate: DateTime!
  disbursementDate: DateTime!
  numberOfHouseholds: Int!
  createdDate: DateTime!
  createdBy: UserNode
  coverageDuration: Int!
  coverageUnits: String!
  targetPopulation: TargetPopulationNode!
  cashAssistId: String!
  distributionModality: String!
  fsp: String!
  status: CashPlanStatus!
  currency: String!
  totalEntitledQuantity: Float!
  totalDeliveredQuantity: Float!
  totalUndeliveredQuantity: Float!
  dispersionDate: Date!
  deliveryType: String!
  assistanceThrough: String!
  fcId: String!
  dpId: String!
  paymentRecords(before: String, after: String, first: Int, last: Int, cashPlan: ID, household: ID): PaymentRecordNodeConnection!
}

type CashPlanNodeConnection {
  pageInfo: PageInfo!
  edges: [CashPlanNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type CashPlanNodeEdge {
  node: CashPlanNode
  cursor: String!
}

enum CashPlanStatus {
  NOT_STARTED
  STARTED
  COMPLETE
}

type ChoiceObject {
  name: String
  value: String
}

input CopyTargetPopulationInput {
  id: ID
  name: String
}

input CopyTargetPopulationMutationInput {
  targetPopulationData: CopyTargetPopulationInput
  clientMutationId: String
}

type CopyTargetPopulationMutationPayload {
  targetPopulation: TargetPopulationNode
  clientMutationId: String
}

type CoreFieldChoiceObject {
  labels: [LabelNode]
  labelEn: String
  value: String
  admin: String
  listName: String
}

type CreateProgram {
  program: ProgramNode
}

input CreateProgramInput {
  name: String
  startDate: Date
  endDate: Date
  description: String
  programCaId: String
  budget: Decimal
  frequencyOfPayments: String
  sector: String
  scope: String
  cashPlus: Boolean
  populationGoal: Int
  administrativeAreasOfImplementation: String
  businessAreaSlug: String
}

type CreateRegistrationDataImport {
  registrationDataImport: RegistrationDataImportNode
}

input CreateRegistrationDataImportExcelInput {
  importDataId: ID
  name: String
}

input CreateTargetPopulationInput {
  name: String!
  targetingCriteria: TargetingCriteriaObjectType!
}

type CreateTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

scalar Date

scalar DateTime

scalar Decimal

type DeleteProgram {
  ok: Boolean
}

type DeleteRegistrationDataImport {
  ok: Boolean
}

input DeleteTargetPopulationMutationInput {
  targetId: ID!
  clientMutationId: String
}

type DeleteTargetPopulationMutationPayload {
  ok: Boolean
  clientMutationId: String
}

type DjangoDebug {
  sql: [DjangoDebugSQL]
}

type DjangoDebugSQL {
  vendor: String!
  alias: String!
  sql: String
  duration: Float!
  rawSql: String!
  params: String!
  startTime: Float!
  stopTime: Float!
  isSlow: Boolean!
  isSelect: Boolean!
  transId: String
  transStatus: String
  isoLevel: String
  encoding: String
}

type DocumentNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  documentNumber: String!
  photo: String!
  individual: IndividualNode!
  type: DocumentTypeNode!
}

type DocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [DocumentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type DocumentNodeEdge {
  node: DocumentNode
  cursor: String!
}

type DocumentTypeNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  country: String
  label: String!
  documents(before: String, after: String, first: Int, last: Int): DocumentNodeConnection!
}

type FieldAttributeNode {
  id: String
  type: String
  name: String
  labels: [LabelNode]
  labelEn: String
  hint: String
  required: Boolean
  choices: [CoreFieldChoiceObject]
  associatedWith: String
  isFlexField: Boolean
}

type FinalizeTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

scalar GeoJSON

type HouseholdNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  consent: String!
  residenceStatus: HouseholdResidenceStatus!
  countryOrigin: String
  country: String
  size: Int!
  address: String!
  adminArea: AdminAreaNode
  geopoint: GeoJSON
  femaleAgeGroup05Count: Int!
  femaleAgeGroup611Count: Int!
  femaleAgeGroup1217Count: Int!
  femaleAdultsCount: Int!
  pregnantCount: Int!
  maleAgeGroup05Count: Int!
  maleAgeGroup611Count: Int!
  maleAgeGroup1217Count: Int!
  maleAdultsCount: Int!
  femaleAgeGroup05DisabledCount: Int!
  femaleAgeGroup611DisabledCount: Int!
  femaleAgeGroup1217DisabledCount: Int!
  femaleAdultsDisabledCount: Int!
  maleAgeGroup05DisabledCount: Int!
  maleAgeGroup611DisabledCount: Int!
  maleAgeGroup1217DisabledCount: Int!
  maleAdultsDisabledCount: Int!
  registrationDataImport: RegistrationDataImportNode!
  programs(before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  returnee: Boolean!
  registrationDate: Date
  headOfHousehold: IndividualNode!
  individuals(before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  paymentRecords(before: String, after: String, first: Int, last: Int, cashPlan: ID, household: ID): PaymentRecordNodeConnection!
  targetPopulations(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, orderBy: String): TargetPopulationNodeConnection!
  totalCashReceived: Decimal
}

type HouseholdNodeConnection {
  pageInfo: PageInfo!
  edges: [HouseholdNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type HouseholdNodeEdge {
  node: HouseholdNode
  cursor: String!
}

enum HouseholdResidenceStatus {
  REFUGEE
  MIGRANT
  CITIZEN
  IDP
  OTHER
}

type ImportDataNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  xlsxFile: String!
  numberOfHouseholds: Int!
  numberOfIndividuals: Int!
  registrationDataImport: RegistrationDataImportDatahubNode
}

type ImportedDocumentNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  documentNumber: String!
  photo: String!
  individual: ImportedIndividualNode!
  type: ImportedDocumentTypeNode!
}

type ImportedDocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedDocumentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedDocumentNodeEdge {
  node: ImportedDocumentNode
  cursor: String!
}

enum ImportedDocumentTypeCountry {
  AF
  AX
  AL
  DZ
  AS
  AD
  AO
  AI
  AQ
  AG
  AR
  AM
  AW
  AU
  AT
  AZ
  BS
  BH
  BD
  BB
  BY
  BE
  BZ
  BJ
  BM
  BT
  BO
  BQ
  BA
  BW
  BV
  BR
  IO
  BN
  BG
  BF
  BI
  CV
  KH
  CM
  CA
  KY
  CF
  TD
  CL
  CN
  CX
  CC
  CO
  KM
  CG
  CD
  CK
  CR
  CI
  HR
  CU
  CW
  CY
  CZ
  DK
  DJ
  DM
  DO
  EC
  EG
  SV
  GQ
  ER
  EE
  SZ
  ET
  FK
  FO
  FJ
  FI
  FR
  GF
  PF
  TF
  GA
  GM
  GE
  DE
  GH
  GI
  GR
  GL
  GD
  GP
  GU
  GT
  GG
  GN
  GW
  GY
  HT
  HM
  VA
  HN
  HK
  HU
  IS
  IN
  ID
  IR
  IQ
  IE
  IM
  IL
  IT
  JM
  JP
  JE
  JO
  KZ
  KE
  KI
  KW
  KG
  LA
  LV
  LB
  LS
  LR
  LY
  LI
  LT
  LU
  MO
  MG
  MW
  MY
  MV
  ML
  MT
  MH
  MQ
  MR
  MU
  YT
  MX
  FM
  MD
  MC
  MN
  ME
  MS
  MA
  MZ
  MM
  NA
  NR
  NP
  NL
  NC
  NZ
  NI
  NE
  NG
  NU
  NF
  KP
  MK
  MP
  NO
  OM
  PK
  PW
  PS
  PA
  PG
  PY
  PE
  PH
  PN
  PL
  PT
  PR
  QA
  RE
  RO
  RU
  RW
  BL
  SH
  KN
  LC
  MF
  PM
  VC
  WS
  SM
  ST
  SA
  SN
  RS
  SC
  SL
  SG
  SX
  SK
  SI
  SB
  SO
  ZA
  GS
  KR
  SS
  ES
  LK
  SD
  SR
  SJ
  SE
  CH
  SY
  TW
  TJ
  TZ
  TH
  TL
  TG
  TK
  TO
  TT
  TN
  TR
  TM
  TC
  TV
  UG
  UA
  AE
  GB
  UM
  US
  UY
  UZ
  VU
  VE
  VN
  VG
  VI
  WF
  EH
  YE
  ZM
  ZW
}

type ImportedDocumentTypeNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  country: ImportedDocumentTypeCountry
  label: String!
  documents(before: String, after: String, first: Int, last: Int): ImportedDocumentNodeConnection!
}

type ImportedHouseholdNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  consent: String!
  residenceStatus: ImportedHouseholdResidenceStatus!
  countryOrigin: String
  size: Int!
  address: String!
  country: String
  admin1: String!
  admin2: String!
  geopoint: GeoJSON
  femaleAgeGroup05Count: Int!
  femaleAgeGroup611Count: Int!
  femaleAgeGroup1217Count: Int!
  femaleAdultsCount: Int!
  pregnantCount: Int!
  maleAgeGroup05Count: Int!
  maleAgeGroup611Count: Int!
  maleAgeGroup1217Count: Int!
  maleAdultsCount: Int!
  femaleAgeGroup05DisabledCount: Int!
  femaleAgeGroup611DisabledCount: Int!
  femaleAgeGroup1217DisabledCount: Int!
  femaleAdultsDisabledCount: Int!
  maleAgeGroup05DisabledCount: Int!
  maleAgeGroup611DisabledCount: Int!
  maleAgeGroup1217DisabledCount: Int!
  maleAdultsDisabledCount: Int!
  headOfHousehold: ImportedIndividualNode
  registrationDataImport: RegistrationDataImportDatahubNode!
  registrationDate: Date
  returnee: Boolean!
  flexFields: JSONString!
  individuals(before: String, after: String, first: Int, last: Int): ImportedIndividualNodeConnection!
}

type ImportedHouseholdNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedHouseholdNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedHouseholdNodeEdge {
  node: ImportedHouseholdNode
  cursor: String!
}

enum ImportedHouseholdResidenceStatus {
  REFUGEE
  MIGRANT
  CITIZEN
  IDP
  OTHER
}

enum ImportedIndividualMaritalStatus {
  SINGLE
  MARRIED
  WIDOW
  DIVORCED
  SEPARATED
}

type ImportedIndividualNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  individualId: String!
  photo: String!
  fullName: String!
  givenName: String!
  middleName: String!
  familyName: String!
  relationship: ImportedIndividualRelationship
  role: ImportedIndividualRole
  sex: ImportedIndividualSex!
  birthDate: Date!
  estimatedBirthDate: Boolean
  maritalStatus: ImportedIndividualMaritalStatus!
  phoneNo: String!
  phoneNoAlternative: String!
  household: ImportedHouseholdNode!
  registrationDataImport: RegistrationDataImportDatahubNode!
  disability: Boolean!
  flexFields: JSONString!
  importedhousehold: ImportedHouseholdNode
  documents(before: String, after: String, first: Int, last: Int): ImportedDocumentNodeConnection!
}

type ImportedIndividualNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedIndividualNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedIndividualNodeEdge {
  node: ImportedIndividualNode
  cursor: String!
}

enum ImportedIndividualRelationship {
  NON_BENEFICIARY
  HEAD
  SON_DAUGHTER
  WIFE_HUSBAND
  BROTHER_SISTER
  MOTHER_FATHER
  AUNT_UNCLE
  GRANDMOTHER_GRANDFATHER
  MOTHERINLAW_FATHERINLAW
  DAUGHTERINLAW_SONINLAW
  SISTERINLAW_BROTHERINLAW
  GRANDDAUGHER_GRANDSON
  NEPHEW_NIECE
  COUSIN
}

enum ImportedIndividualRole {
  PRIMARY
  ALTERNATE
  NO_ROLE
}

enum ImportedIndividualSex {
  MALE
  FEMALE
}

enum IndividualMaritalStatus {
  SINGLE
  MARRIED
  WIDOW
  DIVORCED
  SEPARATED
}

type IndividualNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  individualId: String!
  photo: String!
  fullName: String!
  givenName: String!
  middleName: String!
  familyName: String!
  relationship: IndividualRelationship
  role: String
  sex: IndividualSex!
  birthDate: Date!
  estimatedBirthDate: Boolean
  maritalStatus: IndividualMaritalStatus!
  phoneNo: String!
  phoneNoAlternative: String!
  household: HouseholdNode!
  registrationDataImport: RegistrationDataImportNode!
  disability: Boolean!
  headingHousehold: HouseholdNode
  documents(before: String, after: String, first: Int, last: Int): DocumentNodeConnection!
}

type IndividualNodeConnection {
  pageInfo: PageInfo!
  edges: [IndividualNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type IndividualNodeEdge {
  node: IndividualNode
  cursor: String!
}

enum IndividualRelationship {
  NON_BENEFICIARY
  HEAD
  SON_DAUGHTER
  WIFE_HUSBAND
  BROTHER_SISTER
  MOTHER_FATHER
  AUNT_UNCLE
  GRANDMOTHER_GRANDFATHER
  MOTHERINLAW_FATHERINLAW
  DAUGHTERINLAW_SONINLAW
  SISTERINLAW_BROTHERINLAW
  GRANDDAUGHER_GRANDSON
  NEPHEW_NIECE
  COUSIN
}

enum IndividualSex {
  MALE
  FEMALE
}

scalar JSONLazyString

scalar JSONString

type LabelNode {
  language: String
  label: String
}

enum LogEntryAction {
  A_0
  A_1
  A_2
}

type LogEntryObject {
  id: ID!
  objectPk: String!
  objectId: Int
  objectRepr: String!
  action: LogEntryAction!
  changes: String!
  actor: UserNode
  remoteAddr: String
  timestamp: DateTime
  changesDisplayDict: JSONLazyString
}

type LogEntryObjectConnection {
  pageInfo: PageInfo!
  edges: [LogEntryObjectEdge]!
  totalCount: Int
}

type LogEntryObjectEdge {
  node: LogEntryObject
  cursor: String!
}

type MergeRegistrationDataImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

type Mutations {
  createTargetPopulation(input: CreateTargetPopulationInput!): CreateTargetPopulationMutation
  updateTargetPopulation(input: UpdateTargetPopulationInput!): UpdateTargetPopulationMutation
  copyTargetPopulation(input: CopyTargetPopulationMutationInput!): CopyTargetPopulationMutationPayload
  deleteTargetPopulation(input: DeleteTargetPopulationMutationInput!): DeleteTargetPopulationMutationPayload
  approveTargetPopulation(id: ID!, programId: ID!): ApproveTargetPopulationMutation
  unapproveTargetPopulation(id: ID!): UnapproveTargetPopulationMutation
  finalizeTargetPopulation(id: ID!): FinalizeTargetPopulationMutation
  createProgram(programData: CreateProgramInput!): CreateProgram
  updateProgram(programData: UpdateProgramInput): UpdateProgram
  deleteProgram(programId: String!): DeleteProgram
  uploadImportDataXlsxFile(file: Upload!): UploadImportDataXLSXFile
  deleteRegistrationDataImport(registrationDataImportId: String!): DeleteRegistrationDataImport
  createRegistrationDataImport(registrationDataImportData: CreateRegistrationDataImportExcelInput!): CreateRegistrationDataImport
  approveRegistrationDataImport(id: ID!): ApproveRegistrationDataImportMutation
  unapproveRegistrationDataImport(id: ID!): UnapproveRegistrationDataImportMutation
  mergeRegistrationDataImport(id: ID!): MergeRegistrationDataImportMutation
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum PaymentEntitlementDeliveryType {
  CASH
  DEPOSIT_TO_CARD
  TRANSFER
}

type PaymentEntitlementNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deliveryType: PaymentEntitlementDeliveryType!
  entitlementQuantity: Decimal
  deliveredQuantity: Decimal
  entitlementCardIssueDate: Date
  entitlementCardNumber: String!
  currency: String!
  deliveryDate: DateTime
  transactionReferenceId: String!
  fsp: String!
  paymentRecord: PaymentRecordNode
}

type PaymentRecordNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: PaymentRecordStatus!
  name: String!
  statusDate: DateTime!
  cashAssistId: String!
  cashPlan: CashPlanNode!
  household: HouseholdNode!
  headOfHousehold: String!
  totalPersonCovered: Int!
  distributionModality: String!
  targetPopulation: TargetPopulationNode!
  entitlement: PaymentEntitlementNode
}

type PaymentRecordNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentRecordNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentRecordNodeEdge {
  node: PaymentRecordNode
  cursor: String!
}

enum PaymentRecordStatus {
  SUCCESS
  PENDING
  ERROR
}

enum ProgramFrequencyOfPayments {
  REGULAR
  ONE_OFF
}

type ProgramNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  status: ProgramStatus!
  startDate: Date!
  endDate: Date!
  description: String!
  programCaId: String!
  adminAreas(before: String, after: String, first: Int, last: Int, title: String): AdminAreaNodeConnection!
  businessArea: BusinessAreaNode!
  budget: Decimal
  frequencyOfPayments: ProgramFrequencyOfPayments!
  sector: ProgramSector!
  scope: ProgramScope!
  cashPlus: Boolean!
  populationGoal: Int!
  administrativeAreasOfImplementation: String!
  households(before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  cashPlans(before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  targetpopulationSet(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, orderBy: String): TargetPopulationNodeConnection!
  totalEntitledQuantity: Decimal
  totalDeliveredQuantity: Decimal
  totalUndeliveredQuantity: Decimal
  totalNumberOfHouseholds: Int
  history(before: String, after: String, first: Int, last: Int): LogEntryObjectConnection
}

type ProgramNodeConnection {
  pageInfo: PageInfo!
  edges: [ProgramNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ProgramNodeEdge {
  node: ProgramNode
  cursor: String!
}

enum ProgramScope {
  FULL
  PARTIAL
  NO_INTEGRATION
}

enum ProgramSector {
  CHILD_PROTECTION
  EDUCATION
  GENDER
  HEALTH
  HIV_AIDS
  MULTI_PURPOSE
  NUTRITION
  SOCIAL_POLICY
  WASH
}

enum ProgramStatus {
  DRAFT
  ACTIVE
  FINISHED
}

type Query {
  paymentRecord(id: ID!): PaymentRecordNode
  allPaymentRecords(before: String, after: String, first: Int, last: Int, cashPlan: ID, household: ID, orderBy: String): PaymentRecordNodeConnection
  paymentRecordStatusChoices: [ChoiceObject]
  allPaymentEntitlements: [PaymentEntitlementNode]
  adminArea(id: ID!): AdminAreaNode
  allAdminAreas(before: String, after: String, first: Int, last: Int, title: String, title_Icontains: String, businessArea: String): AdminAreaNodeConnection
  allBusinessAreas(before: String, after: String, first: Int, last: Int, id: UUID): BusinessAreaNodeConnection
  allLogEntries(objectId: String!, before: String, after: String, first: Int, last: Int): LogEntryObjectConnection
  allFieldsAttributes(flexField: Boolean): [FieldAttributeNode]
  program(id: ID!): ProgramNode
  allPrograms(before: String, after: String, first: Int, last: Int, id: UUID, status: String, businessArea: String): ProgramNodeConnection
  cashPlan(id: ID!): CashPlanNode
  allCashPlans(before: String, after: String, first: Int, last: Int, program: ID, orderBy: String): CashPlanNodeConnection
  programStatusChoices: [ChoiceObject]
  programFrequencyOfPaymentsChoices: [ChoiceObject]
  programSectorChoices: [ChoiceObject]
  programScopeChoices: [ChoiceObject]
  cashPlanStatusChoices: [ChoiceObject]
  targetPopulation(id: ID!): TargetPopulationNode
  allTargetPopulation(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, orderBy: String): TargetPopulationNodeConnection
  goldenRecordByTargetingCriteria(targetingCriteria: TargetingCriteriaObjectType!, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection
  candidateHouseholdsListByTargetingCriteria(targetPopulation: ID!, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection
  finalHouseholdsListByTargetingCriteria(targetPopulation: ID!, targetingCriteria: TargetingCriteriaObjectType, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection
  targetPopulationStatusChoices: [ChoiceObject]
  household(id: ID!): HouseholdNode
  allHouseholds(before: String, after: String, first: Int, last: Int, businessArea: String, countryOrigin: String, countryOrigin_Icontains: String, address: String, address_Icontains: String, headOfHousehold_FullName: String, headOfHousehold_FullName_Icontains: String, size_Range: Int, size_Lte: Int, size_Gte: Int, adminArea: ID, targetPopulations: [ID], programs: [ID], residenceStatus: String, size: String, search: String, orderBy: String): HouseholdNodeConnection
  individual(id: ID!): IndividualNode
  allIndividuals(before: String, after: String, first: Int, last: Int, programme: String, businessArea: String, fullName: String, fullName_Icontains: String, sex: [ID], age: String, search: String, orderBy: String): IndividualNodeConnection
  residenceStatusChoices: [ChoiceObject]
  sexChoices: [ChoiceObject]
  maritalStatusChoices: [ChoiceObject]
  relationshipChoices: [ChoiceObject]
  roleChoices: [ChoiceObject]
  me: UserObjectType
  allUsers(before: String, after: String, first: Int, last: Int, fullName: String, orderBy: String): UserNodeConnection
  importedHousehold(id: ID!): ImportedHouseholdNode
  allImportedHouseholds(before: String, after: String, first: Int, last: Int, rdiId: String, orderBy: String): ImportedHouseholdNodeConnection
  registrationDataImportDatahub(id: ID!): RegistrationDataImportDatahubNode
  allRegistrationDataImportsDatahub(before: String, after: String, first: Int, last: Int): RegistrationDataImportDatahubNodeConnection
  importedIndividual(id: ID!): ImportedIndividualNode
  allImportedIndividuals(before: String, after: String, first: Int, last: Int, household: ID, rdiId: String, orderBy: String): ImportedIndividualNodeConnection
  importData(id: ID!): ImportDataNode
  registrationDataImport(id: ID!): RegistrationDataImportNode
  allRegistrationDataImports(before: String, after: String, first: Int, last: Int, importedBy_Id: UUID, importDate: Date, status: String, name: String, name_Icontains: String, orderBy: String): RegistrationDataImportNodeConnection
  registrationDataStatusChoices: [ChoiceObject]
  _debug: DjangoDebug
}

enum RegistrationDataImportDataSource {
  XLS
  A_3RD_PARTY
  XML
  OTHER
}

type RegistrationDataImportDatahubNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  importDate: DateTime!
  hctId: UUID
  importData: ImportDataNode
  households(before: String, after: String, first: Int, last: Int): ImportedHouseholdNodeConnection!
  individuals(before: String, after: String, first: Int, last: Int): ImportedIndividualNodeConnection!
}

type RegistrationDataImportDatahubNodeConnection {
  pageInfo: PageInfo!
  edges: [RegistrationDataImportDatahubNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RegistrationDataImportDatahubNodeEdge {
  node: RegistrationDataImportDatahubNode
  cursor: String!
}

type RegistrationDataImportNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  status: RegistrationDataImportStatus!
  importDate: DateTime!
  importedBy: UserNode!
  dataSource: RegistrationDataImportDataSource!
  numberOfIndividuals: Int!
  numberOfHouseholds: Int!
  datahubId: UUID
  businessArea: BusinessAreaNode
  households(before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individuals(before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
}

type RegistrationDataImportNodeConnection {
  pageInfo: PageInfo!
  edges: [RegistrationDataImportNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RegistrationDataImportNodeEdge {
  node: RegistrationDataImportNode
  cursor: String!
}

enum RegistrationDataImportStatus {
  IN_REVIEW
  APPROVED
  MERGED
  MERGING
}

type TargetPopulationNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  isRemoved: Boolean!
  name: String!
  createdBy: UserNode
  status: TargetPopulationStatus!
  households(before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  candidateListTotalHouseholds: Int
  candidateListTotalIndividuals: Int
  finalListTotalHouseholds: Int
  finalListTotalIndividuals: Int
  selectionComputationMetadata: String
  program: ProgramNode
  candidateListTargetingCriteria: TargetingCriteriaNode
  finalListTargetingCriteria: TargetingCriteriaNode
  paymentRecords(before: String, after: String, first: Int, last: Int, cashPlan: ID, household: ID): PaymentRecordNodeConnection!
  cashPlans(before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  totalHouseholds: Int
  totalFamilySize: Int
  finalList(before: String, after: String, first: Int, last: Int): HouseholdNodeConnection
}

type TargetPopulationNodeConnection {
  pageInfo: PageInfo!
  edges: [TargetPopulationNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TargetPopulationNodeEdge {
  node: TargetPopulationNode
  cursor: String!
}

enum TargetPopulationStatus {
  DRAFT
  APPROVED
  FINALIZED
}

type TargetingCriteriaNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  targetPopulationCandidate: TargetPopulationNode
  targetPopulationFinal: TargetPopulationNode
  rules: [TargetingCriteriaRuleNode]
}

input TargetingCriteriaObjectType {
  rules: [TargetingCriteriaRuleObjectType]
}

enum TargetingCriteriaRuleFilterComparisionMethod {
  EQUALS
  NOT_EQUALS
  CONTAINS
  NOT_CONTAINS
  RANGE
  NOT_IN_RANGE
  GREATER_THAN
  LESS_THAN
}

type TargetingCriteriaRuleFilterNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  comparisionMethod: TargetingCriteriaRuleFilterComparisionMethod!
  targetingCriteriaRule: TargetingCriteriaRuleNode!
  isFlexField: Boolean!
  fieldName: String!
  arguments: [Arg]
  fieldAttribute: FieldAttributeNode
}

input TargetingCriteriaRuleFilterObjectType {
  comparisionMethod: String!
  isFlexField: Boolean!
  fieldName: String!
  arguments: [Arg]!
}

type TargetingCriteriaRuleNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  targetingCriteria: TargetingCriteriaNode!
  filters: [TargetingCriteriaRuleFilterNode]
}

input TargetingCriteriaRuleObjectType {
  filters: [TargetingCriteriaRuleFilterObjectType]
}

scalar UUID

type UnapproveRegistrationDataImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

type UnapproveTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

type UpdateProgram {
  program: ProgramNode
}

input UpdateProgramInput {
  id: String!
  name: String
  status: String
  startDate: Date
  endDate: Date
  description: String
  programCaId: String
  budget: Decimal
  frequencyOfPayments: String
  sector: String
  scope: String
  cashPlus: Boolean
  populationGoal: Int
  administrativeAreasOfImplementation: String
  businessAreaSlug: String
}

input UpdateTargetPopulationInput {
  id: ID!
  name: String
  targetingCriteria: TargetingCriteriaObjectType
}

type UpdateTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

scalar Upload

type UploadImportDataXLSXFile {
  importData: ImportDataNode
  errors: [XlsxRowErrorNode]
}

type UserNode implements Node {
  lastLogin: DateTime
  isSuperuser: Boolean!
  username: String!
  firstName: String!
  lastName: String!
  email: String!
  isStaff: Boolean!
  isActive: Boolean!
  dateJoined: DateTime!
  id: ID!
  businessAreas(before: String, after: String, first: Int, last: Int, id: UUID): BusinessAreaNodeConnection!
  cashPlans(before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  targetPopulations(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, orderBy: String): TargetPopulationNodeConnection!
  registrationDataImports(before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
}

type UserNodeConnection {
  pageInfo: PageInfo!
  edges: [UserNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type UserNodeEdge {
  node: UserNode
  cursor: String!
}

type UserObjectType {
  lastLogin: DateTime
  isSuperuser: Boolean!
  username: String!
  firstName: String!
  lastName: String!
  email: String!
  isStaff: Boolean!
  isActive: Boolean!
  dateJoined: DateTime!
  id: UUID!
  businessAreas(before: String, after: String, first: Int, last: Int, id: UUID): BusinessAreaNodeConnection!
  cashPlans(before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  targetPopulations(before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], candidateListTotalHouseholdsMin: Int, candidateListTotalHouseholdsMax: Int, candidateListTotalIndividualsMin: Int, candidateListTotalIndividualsMax: Int, finalListTotalHouseholdsMin: Int, finalListTotalHouseholdsMax: Int, finalListTotalIndividualsMin: Int, finalListTotalIndividualsMax: Int, orderBy: String): TargetPopulationNodeConnection!
  registrationDataImports(before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
}

type XlsxRowErrorNode {
  rowNumber: Int
  header: String
  message: String
}
